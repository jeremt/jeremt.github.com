
h2: a(href="#/lab/cpp11_functions_tricks") C++11 function tricks

p.
  C++11 provides some features for a more "functionnal" C++. Indeed, there is
  some features such as std::function std::bind or lambdas that make functions
  manipulation much easier. So, I decided to create 2 useful tools to
  manipulate functions.

p.
  The first one store a lambda and its parameters, then call it. It is useful
  when you need to store a function and its paramters and call it later
  (a thread API for instance).

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").
  int n = 2;
  auto triple = makeCallable([] (int &a) {
    a *= 3;
  }, n);

  triple();
  std::cout << n << std::endl;

p.
  The second store a lambda in a generic Function type. Then, you can call it
  after with its paramters via operator(). It's useful to store generic
  functions in contains (for JS like events for example).

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").
  Function triple = [] (int &a) {
    a *= 3;
  };

  int n = 2;
  triple(n);
  std::cout << n << std::endl;

h3 Callable

p.
  The first problem is that the given function can have a variable number
  of parameters of different type. That's why we will use <strong>variadic
  templates</strong>.

p.
  Then, we have to figure out a way to store this paramters within the Callable
  class. And for this, we have exactly what we need:
  <strong>std::tuple</strong>.

p.
  Intially, we will create the <strong>Callable</strong> class, that will
  store the lambda and its paramters at construction:

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").

  // The class is templated on a lambda function and a variadic number of
  // arguments.
  template&lt;typename Lambda, typename... Args&gt;
  struct Callable {
  public:

    // The constructor takes a lambda and some arguments and store it into
    // the class.
    Callable(Lambda const &lambda, Args &&... args) :
      _args(std::forward&lt;Args&gt;(args)...), // forward to keep references
      _lambda(lambda) {
    }

    ~Callable() {}

  private:
    std::tuple&lt;Args...&gt; _args;
    Lambda _lambda;
  };

p.
  Now comes the tricky part: we need to call the function will the arguments
  stored into the tuple. To do so, there is only one solution: interate on
  template parameters to recreate the arguments variadic list, then call the
  lambda. That will be done with the following helper:

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").
  namespace priv {
    template&lt;size_t Count&gt;
    struct CallableHelper {
      template&lt;typename Lambda, typename First, typename ...Args&gt;
      void operator()(Lambda const &lambda, First &&first, Args &&...args) const {
        CallableHelper&lt;Count - 1&gt;()(lambda, first, std::get&lt;Count - 1&gt;(first),
            std::forward&lt;Args&gt;(args)...);
      }
    };

    template&lt;&gt;
    struct CallableHelper&lt;0&gt; {
      template&lt;typename Lambda, typename First, typename ...Args&gt;
      void operator()(Lambda const &lambda, First &&, Args &&...args) const {
        lambda(std::forward&lt;Args&gt;(args)...);
      }
    };
  }

p Used as bellow:

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").
  void call() {
    priv::CallableHelper<sizeof...(Args)>()(_lambda, _args);
  }

p Final result:

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").

  #pragma once

  #include &lt;tuple&gt;
  #include &lt;cstddef&gt;
  #include &lt;memory&gt;

  namespace priv {

  template&lt;size_t Count&gt;
  struct CallableHelper {
    template&lt;typename Lambda, typename First, typename ...Args&gt;
    void operator()(Lambda const &lambda, First &&first, Args &&...args) const {
      CallableHelper&lt;Count - 1&gt;()(lambda, first, std::get&lt;Count - 1&gt;(first),
          std::forward&lt;Args&gt;(args)...);
    }
  };

  template&lt;&gt;
  struct CallableHelper&lt;0&gt; {
    template&lt;typename Lambda, typename First, typename ...Args&gt;
    void operator()(Lambda const &lambda, First &&, Args &&...args) const {
      lambda(std::forward&lt;Args&gt;(args)...);
    }
  };

  }

  template&lt;typename Lambda, typename ...Args&gt;
  struct Callable {
  public:

    Callable(Lambda const &lambda, Args &&...args) :
      _args(std::forward&lt;Args&gt;(args)...),
      _lambda(lambda) {
    }

    ~Callable() {}

    void call() {
      priv::CallableHelper&lt;sizeof...(Args)&gt;()(_lambda, _args);
    }

    void operator()() {
      call();
    }

  private:
    std::tuple&lt;Args...&gt; _args;
    Lambda _lambda;
  };

  // Create the callable. It's a function so the template parameters shouldn't
  // be specified.
  template&lt;typename Lambda, typename ...Args&gt;
  Callable&lt;Lambda, Args...&gt; makeCallable(Lambda &&lambda, Args &&...args) {
    return Callable&lt;Lambda, Args...&gt;(lambda, std::forward&lt;Args&gt;(args)...);
  }

h3 Function

p.
  For this one, the problem is that we should store the lambda without knowing
  its number of paramters or their types. So we have to find them from the
  lambda argument itself.

p.
  Firstly, we need to convert the lambda to an std::function, so we could call
  it later:

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").
  template &lt;typename Lambda&gt;
  struct FunctionHelper
    // Deduce lambda's type from the operator()
    : public FunctionHelper&lt;decltype(&Lambda::operator())&gt;
  {};

  // Function pointer specialization
  template &lt;typename Class, typename Return, typename ...Args&gt;
  struct FunctionHelper&lt;Return(Class::*)(Args...) const&gt; {

  // Declare std::function type from the lambda
    typedef std::function&lt;Return(Args...)&gt; FuncType;
  };

  // Cast to given lambda to its equivalent std::function.
  template &lt;typename Lambda&gt;
  typename FunctionHelper&lt;Lambda&gt;::FuncType makeFunction(Lambda& lambda) {
    return static_cast&lt;typename FunctionHelper&lt;Lambda&gt;::FuncType&gt;(lambda);
  }

p.
  Now, we need to store the function into the class in a generic way. While our
  lambda doesnt inherit from a specific object, the only way to do so is to use
  a void * pointer:

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").
  public:
    template&lt;typename Lambda&gt;
    Function(Lambda const &lambda) {

      // Create a std::function pointer from the lambda.
      auto function = new decltype(priv::makeFunction(lambda))
                                  (priv::makeFunction(lambda));

      // Store in into the class.
      _function  = static_cast&lt;void *&gt;(function);

      // Store function's signature so we can compare it with call's arguments.
      _signature = &typeid(function);

      // Simple function to destroy the function's pointer.
      _deleter = [&] () {
        delete static_cast&lt;decltype(priv::makeFunction(lambda)) *&gt;(_function);
      };
    }

    ~Function() {
      _deleter();
    }

  private:
    void *_function;
    std::type_info const *_signature;
    std::function&lt;void()&gt; _deleter;

p.
  Then, there is the last step: call the function with the given arguments
  from the void * stored in the class.

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").
  template&lt;typename ReturnType = void, typename ...Args&gt;
  ReturnType call(Args &&...args) {

    // Throw an exception if the function isnt initialized.
    if (_function == NULL || _signature == NULL)
      throw std::runtime_error("Call of uninitialized function.");

    // Cast the void * into the real std::function type.
    auto function = static_cast&lt;std::function&lt;ReturnType(Args...)&gt;*&gt;(
      _function);

    // Check whether the signature of the new function is the same as the
    // stored one.
    if (typeid(function) != *(_signature))
      throw std::bad_cast();

    // Then, call the function with the parameters.
    return (*function)(std::forward&lt;Args&gt;(args)...);
  }

p Final result:

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").

  #pragma once

  #include &lt;functional&gt;
  #include &lt;stdexcept&gt;
  #include &lt;typeinfo&gt;

  namespace priv {

  template &lt;typename Lambda&gt;
  struct FunctionHelper
    : public FunctionHelper&lt;decltype(&Lambda::operator())&gt;
  {};

  template &lt;typename Class, typename Return, typename ...Args&gt;
  struct FunctionHelper&lt;Return(Class::*)(Args...) const&gt; {
    typedef std::function&lt;Return(Args...)&gt; FuncType;
  };

  template &lt;typename Lambda&gt;
  typename FunctionHelper&lt;Lambda&gt;::FuncType makeFunction(Lambda& lambda) {
    return static_cast&lt;typename FunctionHelper&lt;Lambda&gt;::FuncType&gt;(lambda);
  }

  }

  // Generic function type to store lambdas. It's basically the same principe as
  // boost::any design pattern applied on lamdas. You can store the lambda
  // without specify any type information, and call it later.
  class Function {
  public:

    // Create an uninitialized function, it should be initialized by assignation
    // operator later.
    Function()
    : _function(NULL)
    , _signature(NULL) {}

    // Create a function from the given `lambda`.
    template&lt;typename Lambda&gt;
    Function(Lambda const &lambda) {
      auto function = new decltype(priv::makeFunction(lambda))
                                  (priv::makeFunction(lambda));
      _function  = static_cast&lt;void*&gt;(function);
      _signature = &typeid(function);
      _deleter = [&] () {
        delete static_cast&lt;decltype(priv::makeFunction(lambda)) *&gt;(_function);
      };
    }

    ~Function() {
      _deleter();
    }

    // Execute the function with the given `args`. If the function returns a
    // value, you should specify its return type in template parameters.
    // If the function isn't initialized or its signature doesn't match the
    // arguments, and exception will be thrown.
    template&lt;typename ReturnType = void, typename ...Args&gt;
    ReturnType call(Args &&...args) {
      if (_function == NULL || _signature == NULL)
        throw std::runtime_error("Call of uninitialized function.");
      auto function = static_cast&lt;std::function&lt;ReturnType(Args...)&gt;*&gt;(
        _function);
      if (typeid(function) != *(_signature))
        throw std::bad_cast();
      return (*function)(std::forward&lt;Args&gt;(args)...);
    }

    // Shortcut to call the function. However, this way doesnt support return
    // type.
    template&lt;typename ...Args&gt;
    void operator()(Args &&...args) {
      call(std::forward&lt;Args&gt;(args)...);
    }

  private:

    void *_function;
    std::type_info const *_signature;
    std::function&lt;void()&gt; _deleter;

  };

h3 Unit tests

p.
  Eventually, there is some unit tests written using
  <a href="https://github.com/jeremt/testy">testy</a> library.

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").

  #include "testy.hpp"
  #include "function.hpp"
  #include "callable.hpp"

  Suite("Functions tricks", {

    describe("Callable",

      it("Should create an empty callable and call it",
        auto cb = makeCallable([] () {});
        cb.call();
      ),

      it("Should create and call a callable with arguments",
        int i = 0;
        auto cb = makeCallable([&i] (int a, int b, int c) {
          i += a + b + c;
        }, 1, 2, 3);
        test(i == 0);
        cb.call();
        test(i == 6);
      ),

      it("Should work in operator() as well",
        int i = 0;
        auto cb = makeCallable([&i] (float value) {
          i += value;
        }, 5);
        cb();
        cb();
        test(i == 10);
      )

    )

    describe("Function",

      it("Should create and call a simple function.",
        int i = 0;
        Function add = [&] (int value) {
          i += value;
        };
        add(1);
        add(1);
        add(1);
        test(i == 3);
      ),

      it("Should create and call a function with referenced parameters",
        int i = 5;
        Function add = [] (int &param, int value) {
          param += value;
        };
        add(i, 5);
        test(i == 10);
      ),

      it("Should create and call a function with return type",
        Function add = [] (double a, double b) {
          return a + b;
        };
        // c++ inference doesnt work on return type :(
        test(add.call&lt;double&gt;(1.0, 0.2) == 1.2);
      )

    )

  })
