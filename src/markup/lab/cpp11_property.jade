p.
  In this article, I'll show you a C++ implementation of properties that I
  designed for a game engine project I'm currently working on. Properties had
  to be non-templated objects, so we can store them into a unordered_map for
  example. However, they need to be able to store values of different types.
  Finally, I wanted to be able to implement the 3 following methods the way I
  wanted:

ul
  li Constructor
  li Setter
  li Getter

p.
  To make easier to understand why I wanted that, I'll give you some examples
  of properties that I wanted to handle:

table
  thead
    tr
      th Type
      th Constructor
      th Setter
      th Getter
  tbody
    tr
      td Vec3
      td Create from a value.
      td Set from a value.
      td Get from a value.
    tr
      td Choice
      td Give the possible values for the properties as an initializer_list.
      td Set the choice to the given input if it's a valid option.
      td Return the currently selected choice.
    tr
      td KeyframeSequence
      td Give the list of keyframes as an initializer_list.
      td Add some keyframes as an initializer_list.
      td Return the current value (the current position for example).

p.
  The following code show you how I will use the class in c++:

div(ui-ace="{onLoad: onEditor, mode: \"c_cpp\", theme: \"flatcolors\"}").
  std::unordered_map&lt;std::string, Property&gt; my_properties;
  my_properties["position"] = new Vec3(0, 0, 1);
  my_properties["shape"] = new Choice({"rectangle", "circle", "triangle"});
  my_properties["anim"] = new KeyframeSequence&lt;Vec3&gt;({
    Keyframe&lt;Vec3&gt;(Vec3(0, 0, 0), Vec3(0.5f, 0, 0), 0.0f, 0.5f, "cubic_out"),
    Keyframe&lt;Vec3&gt;(Vec3(0.5f, 0, 0), Vec3(0.5f, 0.5f, 0), 0.5f, 1.0f, "bounce_out")
  });
  
  my_properties["position"].value&lt;Vec3&gt;().x += 2;
  my_properties["shape"].value&lt;Choice&gt;("circle");
  std::cout &lt;&lt; my_properties["anim"].value&lt;KeyframeSequence&lt;Vec3&gt;&gt;() &lt;&lt; std::endl;

h2 Implementation

p Coming soon!
