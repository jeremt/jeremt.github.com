<!DOCTYPE html>
<style>body {margin: 0;}</style>
<div id="canvas"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
<script id="vertex" type="x-shader/x-vertex">

varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}

</script>
<script id="fragment" type="x-shader/x-fragment">

#ifndef GL_ES
// Non OpenGL ES devices doesnt support precision qualifiers, so we do
// nothing instead
#define lowp
#define mediump
#define highp
#else
// to have functions like fwidth for OpenGL ES or WebGL, the extension should
// be explicitly enabled.
#extension GL_OES_standard_derivatives : enable
#endif

// linear step between edge0 (value=0.) and edge1 (value=1.)
#define linearstep(edge0, edge1, x) clamp((x - (edge0)) / (edge1 - (edge0)), 0.0, 1.0)

uniform lowp vec3 color;
uniform lowp float alpha;
varying highp vec2 vUv;

void main() {
  highp vec2 uvPixel = fwidth(vUv);

  gl_FragColor = vec4(color, alpha);
  vec2 border = linearstep(vec2(0), uvPixel, vUv) *
                linearstep(vec2(0), uvPixel, vec2(1) - vUv);
  gl_FragColor.a = border.x * border.y;
}

</script>
<script>

// config
var angularSpeed = 0.05;
var fov = 45;

// renderer
var renderer = new THREE.WebGLRenderer({alpha: true}); // GL_ALPHA_BLENDING
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// camera
var camera = new THREE.PerspectiveCamera(
  fov, window.innerWidth / window.innerHeight, 1, 1000
);
camera.position.z = 800;

// scene
var scene = new THREE.Scene();

// plane
var plane = new THREE.Mesh(
  new THREE.PlaneGeometry(300, 300),
  new THREE.ShaderMaterial({
    vertexShader: document.getElementById("vertex").innerHTML,
    fragmentShader: document.getElementById("fragment").innerHTML,
    uniforms: {
      color: {type: 'c', value: new THREE.Color(0x3498db)},
      alpha: {type: 'f', value: 1.0}
    }
  })
);
scene.add(plane);

// animation
var lastTime = 0;
!function () {
  var time = new Date().getTime();
  var timeDiff = time - lastTime;
  var angleChange = angularSpeed * timeDiff * 2 * Math.PI / 1000;
  plane.rotation.z += angleChange;
  lastTime = time;

  renderer.render(scene, camera);
  requestAnimationFrame(arguments.callee);
}();

</script>
